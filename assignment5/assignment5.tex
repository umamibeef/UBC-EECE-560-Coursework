\documentclass[10pt, oneside, letterpaper]{article}
\usepackage[margin=1in]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\usepackage{listings}
\lstset{
  backgroundcolor=\color{white}, % choose the background color
  basicstyle=\footnotesize\ttfamily, % size of fonts used for the code
  breaklines=true, % automatic line breaking only at whitespace
  frame=single, % add a frame
  captionpos=b, % sets the caption-position to bottom
  commentstyle=\color{mygreen}, % comment style
  escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
  keywordstyle=\color{blue}, % keyword style
  stringstyle=\color{mymauve}, % string literal style
}
\usepackage{enumitem}
\usepackage{blindtext}
\usepackage{datetime2}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{arydshln} % dash line package for matrices
\usepackage{mathtools}
\usepackage{float}
\usepackage{pgf}

\title{Rational Fitting of Transmission Line Functions}
\author{Assignment 5}
\date{Due: 2021/03/15}

\pagestyle{fancy}
\setlength{\headheight}{23pt}
\setlength{\parskip}{1em}
\fancyhf{}
\chead{Assignment 5 \\ Rational Fitting of Transmission Line Functions}
\rhead{Michel Kakulphimp \\ Student \#63542880}
\lhead{EECE560 \\ UBC MEng}
\cfoot{\thepage}

\begin{document}
\maketitle
\thispagestyle{fancy}

\section{Introduction}

In this assignment, we find an approximation for the frequency dependent characteristic impedance $Z_c(\omega{})$ plotted in the previous assignment (the zero sequence) using Bode's asymptotic tracing technique. This produces a rational function approximation of the characteristic impedance which can in turn be converted into an equivalent circuit for use in the frequency dependent (FD) transmission line model. The original plots are superimposed with the resulting approximation for comparison and the differences are discussed.

\section{Setup}

As suggested in the assignment instructions, the original data was interpolated to create 10 points for every frequency decade, providing a total of 80 points from the original 41 points. This was done using numpy's \texttt{interp} function. During this stage, an $\omega$ value was calculated for every data point for use in the Python control system library \texttt{control}.

The Python \texttt{control} library allows one to easily generate Bode plots from a transfer function. It requires that the numerator and denominator be expanded into a polynomials of the form of $C_{n}s^n + C_{n-1}s^{n-1} + ... + C_2s^2 + C_1s^1 + C_0$. The coefficients $C_n$ are placed in two lists, one for the numerator and another for the denominator and passed into the transfer function creator as follows:

\begin{lstlisting}
        H = K*control.tf(num_coeffs, den_coeffs)}
\end{lstlisting}

where \texttt{num\_coeffs} is a list of the numerator's coefficients and \texttt{den\_coeffs} is a list of the denominator's coefficients. H is the resulting control function object generated by the \texttt{tf} function. The transfer function can also be multiplied by a float constant $K$, but for this assignment it is kept at 1.0. Since every pole and zero will contribute to the starting magnitude of the transfer function, it was necessary to devise a way for the constant to adapt to changes in the poles and zeros as the tracing procedure took place. This process is explained further in this section. The constant $K$ is defined after this process.

With the transfer function defined, the following call is made:

\begin{lstlisting}
        magnitude, phase, frequencies = control.bode_plot(H, interp_w_data)
\end{lstlisting}

where \texttt{magnitude} is a list of the magnitude data points, \texttt{phase} is a list of the phase data points, and \texttt{frequencies} is a list of the frequencies in $Hz$. $H$ is the transfer function we created above and \texttt{interp\_w\_data} is a list of the $\omega{}$ values we calculated from the frequency data points, matching those of the original CSV interpreted values.

The coefficients for the transfer function above were obtained programmatically using the Python \texttt{SymPy} library, which performs symbolic computation. Each pole and zero was added manually as a frequency value in $Hz$ in either the pole or zero list. The frequency pole and zero lists are then converted to their angular frequency equivalents. These lists are then used to generate the numerator and denominator polynomials. First, they are turned into the factored form of the polynomial in the form of $(s + p_n)(s + p_{n-1})...(s + p_1)(s + p_0)$. \texttt{SymPy} then converts this polynomial into its expanded form, for both the numerator and the denominator. From these polynomial, the coefficients are extracted.

\begin{alignat}{2}
Z_{eq}(s) &= K\frac{(s + z_1)(s + z_2)(s + z_3)(s + z_4)}{(s + p_1)(s + p_2)(s + p_3)(s + p_4)} \\
Z_{eq}(s) &= K\frac{N_4s^4 + N_3s^3 + N_2s^2 + N_1s^1 + N_0}{D_4s^4 + D_3s^3 + D_2s^2 + D_1s^1 + D_0} \\
\end{alignat}

The numerator and denominator polynomial must also be converted into a series of simple fractions using partial fraction decomposition. This is also performed using \texttt{SymPy} using its \texttt{apart} function. These simple fraction are required to obtain an equivalent RC network representation, using the following relationships.

\begin{alignat}{2}
Z_{eq}(s) &= K_0 + \frac{K_1}{s + p_1} + \frac{K_2}{s + p_2} + \frac{K_3}{s + p_3} + \frac{K_4}{s + p_4} \\
Z_{eq}(s) &= R_0 + \frac{\frac{1}{C_1}}{s + R_1C_1} + \frac{\frac{1}{C_2}}{s + R_2C_2} + \frac{\frac{1}{C_3}}{s + R_3C_3} + \frac{\frac{1}{C_4}}{s + R_4C_4} \\
R_0 &= K_0 \\
R_i &= \frac{K_i}{p_i} \\
C_i &= \frac{1}{K_i}
\end{alignat}

\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{equivalent-rc-network.png}
  \caption{Equivalent R and C network for $Z_c(\omega{})$}
  \label{zc_rc_network}
\end{figure}

To account for the varying starting magnitude as poles and zeros were added to the transfer function, the resulting starting magnitude value from the \texttt{bode\_plot} function was used to determine how much the entire transfer function should be scaled by, by comparing it to the starting magnitude of the original $Z_c(\omega{})$ function. Using this scaling factor, the entire Bode plot \texttt{magnitude} list was multiplied by this scaling factor to scale it up to the original $Z_c(\omega{})$ function. This has the effect of defining the transfer function's $K$ constant. This automatic scaling meant that the starting magnitude of the transfer function was automatically generated to match that of the original function.

With the program now dynamically generating Bode plots superimposed onto the original data using a list of pole and zero frequencies, the curve fitting process took place. The Bode plot was constructed one pole and one zero at a time, checking the resulting plot at every step. This required a fair bit of trial and error until all of the values were obtained. The resulting poles and zeros are outlined in the following section.

\section{Results}

After some trial and error, the following zeros and poles were chosen for the rational approximations.

\begin{table}[H]
\centering
\begin{tabular}{r|c|c|c|c}
Zeros ($Hz$) & 1.8 & 107 & 3.5e3 & 2.27e5 \\ \hline
Poles ($Hz$) & 1.5 & 90 & 3e3 & 2e5
\end{tabular}
\caption{Poles and zeros chosen for rational approximation}
\label{tab:zero-pole-results}
\end{table}

As outlined previously, these were converted into their angular frequency equivalents and used to create the factored form of the the numerator and denominator polynomials used in the transfer function. The following shows the resulting transfer function used for the rational approximation and the resulting $R_i$ and $C_i$ component values for the equivalent network circuit.

\begin{alignat}{2}
Z_{eq}(s) &= \frac{470.88 s^{4} + 6.8229 \cdot 10^{8} s^{3} + 1.5235 \cdot 10^{13} s^{2} + 1.0093 \cdot 10^{16} s + 1.0917 \cdot 10^{17}}{s^{4} + 1.2761 \cdot 10^{6} s^{3} + 2.4418 \cdot 10^{10} s^{2} + 1.3602 \cdot 10^{13} s + 1.2045 \cdot 10^{14}} \\
Z_{eq}(s) &= 470.88 + \frac{165.24}{0.11111 s + 1.0} + \frac{118.19}{0.0017699 s + 1.0} + \frac{88.719}{5.3053 \cdot 10^{-5} s + 1.0} + \frac{63.402}{7.9578 \cdot 10^{-7} s + 1.0} \\
Z_{eq}(s) &= 470.88 + \frac{1.48717\cdot 10^{3}}{s + 9.00009} + \frac{66.7778\cdot 10^{3}}{s + 565.004} + \frac{1.67227\cdot 10^{6}}{s + 18.8491\cdot 10^{3}} + \frac{79.6728\cdot 10^{6}}{s + 1.25663\cdot 10^{6}} \\
Z_{eq}(s) &= K_0 + \frac{K_1}{s + p_1} + \frac{K_2}{s + p_2} + \frac{K_3}{s + p_3} + \frac{K_4}{s + p_4} \\
Z_{eq}(s) &= R_0 + \frac{\frac{1}{C_1}}{s + R_1C_1} + \frac{\frac{1}{C_2}}{s + R_2C_2} + \frac{\frac{1}{C_3}}{s + R_3C_3} + \frac{\frac{1}{C_4}}{s + R_4C_4} \\
R_0 &= K_0 \\
R_i &= \frac{K_i}{p_i} \\
C_i &= \frac{1}{K_i}
\end{alignat}

\begin{table}[H]
\centering
\begin{tabular}{r|c|c|c|c|c}
$i$    & 0   & 1   & 2   & 3     & 4 \\ \hline
$R_i$ & 470.88 $k\Omega{}/km$ & 165.24 $k\Omega{}/km$ & 118.19 $k\Omega{}/km$ & 88.72 $k\Omega{}/km$ & 63.40 $k\Omega{}/km$ \\ \hline
$C_i$ & - & 672.42 $\mu{}F/km$ & 14.98 $\mu{}F/km$ & 598.00 $nF/km$ & 12.55 $nF/km$ 
\end{tabular}
\caption{$R_i$ and $C_i$ network values derived from rational approximation}
\label{tab:rc-results}
\end{table}

The Bode plot of the rational approximation function was superimposed on the $Z_c(\omega{})$ and is plotted in Figure \ref{zc_plots}. The zeros and poles chosen for the rational approximation are also shown as vertical lines to help illustrate how they form the rational approximation.

\begin{figure}[H]
    \begin{center}
        \input{zc_magnitude_and_phase_plot.pgf}
    \end{center}
    \caption{$Z_c(\omega{})$ Original and Approximation Magnitude and Phase vs. Frequency Plots}
    \label{zc_plots}
\end{figure}

\newpage
\section{Conclusion}
The rational approximation generated a fairly reasonable approximation of the frequency dependent characteristic impedance $Z_c(\omega{})$ in terms of both magnitude and phase.
\begin{itemize}
    \item The magnitude fit was completely within the control of the zeros and poles; therefore, its fit was very close to that of the original characteristic impedance. As described in the earlier sections, the starting magnitude was automatically adjusted when the zeros and poles were added and adjusted, so it matches exactly the original characteristic impedance at DC. The final zero was chosen to try to make the final magnitude of the rational fit match as closely as possible to the original characteristic impedance, and this was successful as well.
    \item The phase fit was surprisingly close to the phase of the original characteristic impedance. At approximately 250 $Hz$ we see the largest difference of approximately 0.07$\pi$ which is quite small. The plot makes these differences look larger than they actually are. It was also observed that the phase matches very well at either extremity of the phase plot. If more zeros and poles were used, it is predicted that the phase match would be even closer, although we can see that four poles is largely sufficient.
    \item As described in earlier sections, the Bode plot was plotted every time a new zero or pole was added to the plot. This was immensely helpful in quickly choosing through trial and error the correct values to shape the resulting rational approximation. It was easiest to choose the zeros and poles as a pair, with the zero at a slightly higher frequency than the pole. The values were then tweaked to make the resulting Bode plot of the rational approximation match the original characteristic as closely as possible. This was repeated four times in total for each zero/pole pair. The automatic scaling of the constant $K$ which multiplied the entire transfer function was also immensely helpful in this task.
    \item The process of trial error to choose the different zeros and poles for the rational approximation was likely not the most efficient way of creating it. It may in fact be possible to have the program sweep through different combinations of zeros and poles to obtain an even better match. The program could work a zero/pole pair at a time and attempt to minimize the magnitude difference within a working window. This window would be approximately a decade wide for each pair. It was observed that the delta between the zero/pole frequency pair was proportional to the slope of the curve it was attempting to fit. The steeper the slope, the wider the zero/pole pair frequency bandwidth. Understanding this relationship would help choose an appropriate zero/pole pair to begin the fitment at a given frequency. Equally spacing out the zero/pole pairs across the entire fitting spectrum also allows for the greatest fitting flexibility and the program would also try to maintain this spacing (given a characteristic impedance like the one used in this assignment).
    \item An interesting exercise would be to take the equivalent circuit this circuit generates and use it model the frequency dependent transmission line and compare it to a model that PSCAD supports.
    \item Another interesting exercise would be to create additional rational approximations with less and more poles and try to determine what the most ideal and/or practical number of poles is.
    \item An open question is: how well does this model work for radio frequencies? Are there other high frequency effects, such as the skin effect, that would affect the utility of a model like this or is the frequency dependent model still effective at characterizing radio frequencies?
\end{itemize}

\newpage
\section{Code Listings and Data}

\subsection{Python Code Listing}
\label{code-listing-python}
The following is the code written in Python to perform the calculations derived for this homework assignment as well as generate the plots used in this report. The transmission line parameters were converted to a CSV file which is read in by this Python script.
\lstinputlisting[language=Python]{assignment5.py}

\end{document}

